import Phaser from 'phaser';

/**
 * Sound Manager - Handles all audio effects and music
 */
export class SoundManager {
  private scene: Phaser.Scene;
  private sounds: Map<string, Phaser.Sound.BaseSound> = new Map();
  private musicVolume: number = 0.7;
  private sfxVolume: number = 0.8;
  private musicEnabled: boolean = true;
  private sfxEnabled: boolean = true;
  
  constructor(scene: Phaser.Scene) {
    this.scene = scene;
    this.preloadSounds();
  }
  
  private preloadSounds(): void {\n    // Note: In a real implementation, you would load actual audio files\n    // For now, we'll create placeholder sounds using Web Audio API\n    \n    this.createSynthSounds();\n  }\n  \n  private createSynthSounds(): void {\n    // Create synthetic sounds using Web Audio API for immediate functionality\n    // These would be replaced with actual audio files in production\n    \n    const audioContext = (this.scene.sound as any).context;\n    if (!audioContext) return;\n    \n    // Food eaten sound (short beep)\n    this.createBeepSound('food_eaten', 440, 0.1, 'triangle');\n    \n    // Golden apple sound (higher pitched beep)\n    this.createBeepSound('golden_apple', 660, 0.15, 'sine');\n    \n    // Power-up activation (ascending notes)\n    this.createPowerUpSound('power_up', [330, 440, 550], 0.3);\n    \n    // Game over sound (descending notes)\n    this.createGameOverSound('game_over');\n    \n    // Level complete (victory fanfare)\n    this.createVictorySound('level_complete');\n    \n    // Button click\n    this.createBeepSound('button_click', 220, 0.05, 'square');\n    \n    // Purchase success\n    this.createChimeSound('purchase_success');\n    \n    // Snake movement (subtle tick)\n    this.createTickSound('snake_move');\n    \n    // Bomb food warning\n    this.createWarningSound('bomb_warning');\n    \n    // Speed boost effect\n    this.createWhooshSound('speed_boost');\n  }\n  \n  private createBeepSound(\n    name: string, \n    frequency: number, \n    duration: number, \n    waveType: OscillatorType = 'sine'\n  ): void {\n    // Create a simple beep sound\n    const sound = {\n      play: () => {\n        if (!this.sfxEnabled) return;\n        \n        const audioContext = new AudioContext();\n        const oscillator = audioContext.createOscillator();\n        const gainNode = audioContext.createGain();\n        \n        oscillator.connect(gainNode);\n        gainNode.connect(audioContext.destination);\n        \n        oscillator.frequency.value = frequency;\n        oscillator.type = waveType;\n        \n        gainNode.gain.setValueAtTime(this.sfxVolume * 0.3, audioContext.currentTime);\n        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);\n        \n        oscillator.start();\n        oscillator.stop(audioContext.currentTime + duration);\n      },\n      setVolume: (volume: number) => {}, // Placeholder\n      stop: () => {} // Placeholder\n    };\n    \n    this.sounds.set(name, sound as any);\n  }\n  \n  private createPowerUpSound(name: string, frequencies: number[], duration: number): void {\n    const sound = {\n      play: () => {\n        if (!this.sfxEnabled) return;\n        \n        frequencies.forEach((freq, index) => {\n          setTimeout(() => {\n            const audioContext = new AudioContext();\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n            \n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            \n            oscillator.frequency.value = freq;\n            oscillator.type = 'sine';\n            \n            gainNode.gain.setValueAtTime(this.sfxVolume * 0.2, audioContext.currentTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);\n            \n            oscillator.start();\n            oscillator.stop(audioContext.currentTime + 0.2);\n          }, index * 100);\n        });\n      },\n      setVolume: (volume: number) => {},\n      stop: () => {}\n    };\n    \n    this.sounds.set(name, sound as any);\n  }\n  \n  private createGameOverSound(name: string): void {\n    const sound = {\n      play: () => {\n        if (!this.sfxEnabled) return;\n        \n        const frequencies = [440, 369, 329, 293]; // A4, F#4, E4, D4\n        frequencies.forEach((freq, index) => {\n          setTimeout(() => {\n            const audioContext = new AudioContext();\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n            \n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            \n            oscillator.frequency.value = freq;\n            oscillator.type = 'sine';\n            \n            gainNode.gain.setValueAtTime(this.sfxVolume * 0.3, audioContext.currentTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);\n            \n            oscillator.start();\n            oscillator.stop(audioContext.currentTime + 0.5);\n          }, index * 200);\n        });\n      },\n      setVolume: (volume: number) => {},\n      stop: () => {}\n    };\n    \n    this.sounds.set(name, sound as any);\n  }\n  \n  private createVictorySound(name: string): void {\n    const sound = {\n      play: () => {\n        if (!this.sfxEnabled) return;\n        \n        const melody = [261, 329, 392, 523]; // C4, E4, G4, C5\n        melody.forEach((freq, index) => {\n          setTimeout(() => {\n            const audioContext = new AudioContext();\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n            \n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            \n            oscillator.frequency.value = freq;\n            oscillator.type = 'triangle';\n            \n            gainNode.gain.setValueAtTime(this.sfxVolume * 0.4, audioContext.currentTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);\n            \n            oscillator.start();\n            oscillator.stop(audioContext.currentTime + 0.3);\n          }, index * 150);\n        });\n      },\n      setVolume: (volume: number) => {},\n      stop: () => {}\n    };\n    \n    this.sounds.set(name, sound as any);\n  }\n  \n  private createChimeSound(name: string): void {\n    const sound = {\n      play: () => {\n        if (!this.sfxEnabled) return;\n        \n        [523, 659, 784].forEach((freq, index) => {\n          setTimeout(() => {\n            const audioContext = new AudioContext();\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n            \n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            \n            oscillator.frequency.value = freq;\n            oscillator.type = 'sine';\n            \n            gainNode.gain.setValueAtTime(this.sfxVolume * 0.2, audioContext.currentTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);\n            \n            oscillator.start();\n            oscillator.stop(audioContext.currentTime + 0.4);\n          }, index * 100);\n        });\n      },\n      setVolume: (volume: number) => {},\n      stop: () => {}\n    };\n    \n    this.sounds.set(name, sound as any);\n  }\n  \n  private createTickSound(name: string): void {\n    const sound = {\n      play: () => {\n        if (!this.sfxEnabled) return;\n        \n        const audioContext = new AudioContext();\n        const oscillator = audioContext.createOscillator();\n        const gainNode = audioContext.createGain();\n        \n        oscillator.connect(gainNode);\n        gainNode.connect(audioContext.destination);\n        \n        oscillator.frequency.value = 800;\n        oscillator.type = 'square';\n        \n        gainNode.gain.setValueAtTime(this.sfxVolume * 0.1, audioContext.currentTime);\n        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.02);\n        \n        oscillator.start();\n        oscillator.stop(audioContext.currentTime + 0.02);\n      },\n      setVolume: (volume: number) => {},\n      stop: () => {}\n    };\n    \n    this.sounds.set(name, sound as any);\n  }\n  \n  private createWarningSound(name: string): void {\n    const sound = {\n      play: () => {\n        if (!this.sfxEnabled) return;\n        \n        for (let i = 0; i < 3; i++) {\n          setTimeout(() => {\n            const audioContext = new AudioContext();\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n            \n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            \n            oscillator.frequency.value = 200;\n            oscillator.type = 'sawtooth';\n            \n            gainNode.gain.setValueAtTime(this.sfxVolume * 0.3, audioContext.currentTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);\n            \n            oscillator.start();\n            oscillator.stop(audioContext.currentTime + 0.1);\n          }, i * 150);\n        }\n      },\n      setVolume: (volume: number) => {},\n      stop: () => {}\n    };\n    \n    this.sounds.set(name, sound as any);\n  }\n  \n  private createWhooshSound(name: string): void {\n    const sound = {\n      play: () => {\n        if (!this.sfxEnabled) return;\n        \n        const audioContext = new AudioContext();\n        const oscillator = audioContext.createOscillator();\n        const gainNode = audioContext.createGain();\n        \n        oscillator.connect(gainNode);\n        gainNode.connect(audioContext.destination);\n        \n        oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);\n        oscillator.frequency.exponentialRampToValueAtTime(2000, audioContext.currentTime + 0.3);\n        oscillator.type = 'sawtooth';\n        \n        gainNode.gain.setValueAtTime(this.sfxVolume * 0.2, audioContext.currentTime);\n        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);\n        \n        oscillator.start();\n        oscillator.stop(audioContext.currentTime + 0.3);\n      },\n      setVolume: (volume: number) => {},\n      stop: () => {}\n    };\n    \n    this.sounds.set(name, sound as any);\n  }\n  \n  // Public methods\n  \n  /**\n   * Play a sound effect\n   */\n  public playSound(soundName: string, volume?: number): void {\n    const sound = this.sounds.get(soundName);\n    if (!sound || !this.sfxEnabled) return;\n    \n    if (volume !== undefined) {\n      sound.setVolume(volume * this.sfxVolume);\n    }\n    \n    sound.play();\n  }\n  \n  /**\n   * Play food eaten sound based on food type\n   */\n  public playFoodSound(foodType: string): void {\n    switch (foodType) {\n      case 'golden':\n        this.playSound('golden_apple');\n        break;\n      case 'speed':\n      case 'power':\n      case 'multi':\n        this.playSound('power_up');\n        break;\n      case 'bomb':\n        this.playSound('bomb_warning');\n        break;\n      default:\n        this.playSound('food_eaten');\n    }\n  }\n  \n  /**\n   * Play background music (looped)\n   */\n  public playMusic(musicName: string, loop: boolean = true): void {\n    if (!this.musicEnabled) return;\n    \n    // Stop current music\n    this.stopMusic();\n    \n    // In a real implementation, you would load and play actual music files\n    // For now, we'll create a simple ambient background tone\n    this.createBackgroundMusic(musicName);\n  }\n  \n  private createBackgroundMusic(name: string): void {\n    if (!this.musicEnabled) return;\n    \n    // Create a subtle ambient background tone\n    const audioContext = new AudioContext();\n    const oscillator1 = audioContext.createOscillator();\n    const oscillator2 = audioContext.createOscillator();\n    const gainNode = audioContext.createGain();\n    \n    oscillator1.connect(gainNode);\n    oscillator2.connect(gainNode);\n    gainNode.connect(audioContext.destination);\n    \n    // Create a subtle pad sound\n    oscillator1.frequency.value = 110; // Low A\n    oscillator2.frequency.value = 165; // E above A\n    oscillator1.type = 'sine';\n    oscillator2.type = 'sine';\n    \n    gainNode.gain.setValueAtTime(this.musicVolume * 0.1, audioContext.currentTime);\n    \n    oscillator1.start();\n    oscillator2.start();\n    \n    // Store reference for stopping later\n    this.sounds.set('background_music', {\n      play: () => {},\n      setVolume: (volume: number) => {\n        gainNode.gain.setValueAtTime(volume * this.musicVolume * 0.1, audioContext.currentTime);\n      },\n      stop: () => {\n        oscillator1.stop();\n        oscillator2.stop();\n      }\n    } as any);\n  }\n  \n  /**\n   * Stop background music\n   */\n  public stopMusic(): void {\n    const music = this.sounds.get('background_music');\n    if (music) {\n      music.stop();\n      this.sounds.delete('background_music');\n    }\n  }\n  \n  /**\n   * Set music volume (0-1)\n   */\n  public setMusicVolume(volume: number): void {\n    this.musicVolume = Math.max(0, Math.min(1, volume));\n    \n    const music = this.sounds.get('background_music');\n    if (music) {\n      music.setVolume(this.musicVolume);\n    }\n  }\n  \n  /**\n   * Set sound effects volume (0-1)\n   */\n  public setSFXVolume(volume: number): void {\n    this.sfxVolume = Math.max(0, Math.min(1, volume));\n  }\n  \n  /**\n   * Enable/disable music\n   */\n  public setMusicEnabled(enabled: boolean): void {\n    this.musicEnabled = enabled;\n    \n    if (!enabled) {\n      this.stopMusic();\n    }\n  }\n  \n  /**\n   * Enable/disable sound effects\n   */\n  public setSFXEnabled(enabled: boolean): void {\n    this.sfxEnabled = enabled;\n  }\n  \n  /**\n   * Get current music volume\n   */\n  public getMusicVolume(): number {\n    return this.musicVolume;\n  }\n  \n  /**\n   * Get current SFX volume\n   */\n  public getSFXVolume(): number {\n    return this.sfxVolume;\n  }\n  \n  /**\n   * Check if music is enabled\n   */\n  public isMusicEnabled(): boolean {\n    return this.musicEnabled;\n  }\n  \n  /**\n   * Check if SFX is enabled\n   */\n  public isSFXEnabled(): boolean {\n    return this.sfxEnabled;\n  }\n  \n  /**\n   * Stop all sounds\n   */\n  public stopAllSounds(): void {\n    this.sounds.forEach(sound => {\n      sound.stop();\n    });\n    this.sounds.clear();\n  }\n  \n  /**\n   * Cleanup resources\n   */\n  public destroy(): void {\n    this.stopAllSounds();\n  }\n}